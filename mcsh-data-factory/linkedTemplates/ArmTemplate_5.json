{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "mcsh-data-factory"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/EmployeeProfile_From_GreenHR_copy1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/EVS"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Evs_csv",
								"type": "DatasetReference"
							},
							"name": "sourceEmployees"
						},
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "existingAllSources"
						},
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "existingSource0"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "insertNewEmployees",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService_err",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "ADLS_Raw_CSV",
								"type": "DatasetReference"
							},
							"name": "archiveToDataLake"
						},
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "deleteOldSource0"
						}
					],
					"transformations": [
						{
							"name": "transformStatusAndSource"
						},
						{
							"name": "removeDuplicatesInSource"
						},
						{
							"name": "extractNumberFromGname"
						},
						{
							"name": "joinWithAllExisting"
						},
						{
							"name": "filterOnlyNewEmployees"
						},
						{
							"name": "selectAllSourcesKeys"
						},
						{
							"name": "selectSource0Keys"
						},
						{
							"name": "markForInsert"
						},
						{
							"name": "markForDelete"
						}
					],
					"scriptLines": [
						"source(output(",
						"          fn as string,",
						"          ln as string,",
						"          rn as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          status as string,",
						"          empid as integer,",
						"          status_date as timestamp,",
						"          is_foreigner as boolean",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false) ~> sourceEmployees",
						"source(output(",
						"          rn as string,",
						"          oid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT DISTINCT rn, oid FROM employee_profile',",
						"     format: 'query') ~> existingAllSources",
						"source(output(",
						"          id as integer,",
						"          rn as string,",
						"          oid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT id, rn, oid FROM employee_profile WHERE source = 0',",
						"     format: 'query') ~> existingSource0",
						"sourceEmployees derive(status = iif(status == 'Идэвхтэй', 1,",
						"            iif(status == 'Ажлаас Гарсан', 2,",
						"                iif(status == 'Шилжсэн', 2,",
						"                    iif(status == 'Түр Эзгүй', 3, toInteger(null()))))),",
						"          is_foreigner = iif(is_foreigner == true(), 1, 0),",
						"          source = 0,",
						"          rn = trim(toString(rn)),",
						"          oid = trim(toString(oid))) ~> transformStatusAndSource",
						"extractNumberFromGname aggregate(groupBy(rn,",
						"          oid),",
						"     fn = last(fn),",
						"          ln = last(ln),",
						"          po = last(po),",
						"          gname = last(gname),",
						"          status = last(status),",
						"          empid = last(empid),",
						"          status_date = max(status_date),",
						"          is_foreigner = last(is_foreigner),",
						"          source = last(source),",
						"          gname_number = last(gname_number)) ~> removeDuplicatesInSource",
						"transformStatusAndSource derive(gname_number = toInteger(regexReplace(gname, '[^0-9]', ''))) ~> extractNumberFromGname",
						"removeDuplicatesInSource, selectAllSourcesKeys join(rn == existing_rn",
						"     && oid == existing_oid,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinWithAllExisting",
						"joinWithAllExisting filter(isNull(existing_rn)) ~> filterOnlyNewEmployees",
						"existingAllSources select(mapColumn(",
						"          existing_rn = rn,",
						"          existing_oid = oid",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectAllSourcesKeys",
						"existingSource0 select(mapColumn(",
						"          delete_id = id,",
						"          delete_rn = rn,",
						"          delete_oid = oid",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectSource0Keys",
						"filterOnlyNewEmployees alterRow(insertIf(true())) ~> markForInsert",
						"selectSource0Keys alterRow(deleteIf(true())) ~> markForDelete",
						"markForInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          fn as string,",
						"          rn as string,",
						"          ln as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          empid as integer,",
						"          im as string,",
						"          source as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          status_date as timestamp,",
						"          status as integer,",
						"          gname_number as integer,",
						"          is_foreigner as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> insertNewEmployees",
						"joinWithAllExisting sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['employee_monthly_load.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> archiveToDataLake",
						"markForDelete sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          fn as string,",
						"          rn as string,",
						"          ln as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          empid as integer,",
						"          im as string,",
						"          source as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          status_date as timestamp,",
						"          status as integer,",
						"          gname_number as integer,",
						"          is_foreigner as integer",
						"     ),",
						"     deletable:true,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:false,",
						"     keys:['delete_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1) ~> deleteOldSource0"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/EmployeeProfile_deletes')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/EVS"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "existingSource0"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "deleteOldSource0"
						}
					],
					"transformations": [
						{
							"name": "selectSource0Keys"
						},
						{
							"name": "markForDelete"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as integer,",
						"          rn as string,",
						"          oid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT id, rn, oid FROM employee_profile WHERE source = 0',",
						"     format: 'query') ~> existingSource0",
						"existingSource0 select(mapColumn(",
						"          id,",
						"          delete_rn = rn,",
						"          delete_oid = oid",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectSource0Keys",
						"selectSource0Keys alterRow(deleteIf(true())) ~> markForDelete",
						"markForDelete sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          fn as string,",
						"          rn as string,",
						"          ln as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          empid as integer,",
						"          im as string,",
						"          source as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          status_date as timestamp,",
						"          status as integer,",
						"          gname_number as integer,",
						"          is_foreigner as integer",
						"     ),",
						"     deletable:true,",
						"     insertable:false,",
						"     updateable:false,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 0) ~> deleteOldSource0"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Employee_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_Employee",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_EMPLOYEE",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService1",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "transform1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as string,",
						"          CODE as string,",
						"          FAMILYNAME as string,",
						"          LASTNAME as string,",
						"          FIRSTNAME as string,",
						"          GENDER as string,",
						"          BIRTHDATE as string,",
						"          BIRTHCOUNTRYID as string,",
						"          BIRTHDIVISIONID as string,",
						"          BIRTHDISTRICTID as string,",
						"          BIRTHPLACE as string,",
						"          COUNTRYID as string,",
						"          DIVISIONID as string,",
						"          DISTRICTID as string,",
						"          NATIONALITYID as string,",
						"          SOCIALORIGINID as string,",
						"          MARITALSTATUS as string,",
						"          BLOODGROUP as string,",
						"          REGNO as string,",
						"          PASSNO as string,",
						"          FORPASSNO as string,",
						"          EMDNO as string,",
						"          NDDNO as string,",
						"          ADDR1 as string,",
						"          ADDR2 as string,",
						"          HOMEPHONE as string,",
						"          MOBILEPHONE as string,",
						"          WORKPHONE as string,",
						"          WORKPHONEEXT as string,",
						"          FAX as string,",
						"          EMAIL as string,",
						"          POSTADDRESS as string,",
						"          CONTACTNAME as string,",
						"          CONTACTPHONE as string,",
						"          WITHPICTURE as string,",
						"          STATUS as string,",
						"          CREATED as string,",
						"          CREATEDBY as string,",
						"          UPDATED as string,",
						"          UPDATEDBY as string,",
						"          IPADDRESS as string,",
						"          MACADDRESS as string,",
						"          TSTAMP as string,",
						"          COMPANYID as string,",
						"          STATUSDATE as string,",
						"          LASTNAMELENGTH as string,",
						"          EMAIL2 as string,",
						"          CONTACTNAME2 as string,",
						"          CONTACTPHONE2 as string,",
						"          ISBLACKLISTED as string,",
						"          BLACKLISTREASON as string,",
						"          BLACKLISTEDDATE as string,",
						"          ISFOREIGNER as string,",
						"          CONTACTID as string,",
						"          MILITARYSERVED as string,",
						"          TRAININGSPORT as string,",
						"          INTEREST as string,",
						"          APPID as string,",
						"          MILITARYNO as string,",
						"          RELATIVEID as string,",
						"          RELATIVEID2 as string,",
						"          MILITARYCLOSETYPE as string,",
						"          MILITARYCOMMENT as string,",
						"          LINKEDIN as string,",
						"          FACEBOOK as string,",
						"          TWITTER as string,",
						"          ISSPYOATH as string,",
						"          SPYOATHDATE as string,",
						"          ISGOVERNMENTOATH as string,",
						"          GOVERNMENTOATHDATE as string,",
						"          ISMILITARYOATH as string,",
						"          MILITARYOATHDATE as string,",
						"          LINKID as string,",
						"          ISRESIDENT as string,",
						"          CIVILID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source1 derive(source_system_code = '0',",
						"          source_employee_id = EMPID,",
						"          company_id = iif(isNull(COMPANYID),\"NO\",COMPANYID),",
						"          employee_code = CODE,",
						"          registration_number = REGNO,",
						"          family_name = FAMILYNAME,",
						"          last_name = LASTNAME,",
						"          first_name = FIRSTNAME,",
						"          birth_date = toDate(BIRTHDATE, 'yyyy.MM.dd'),",
						"          nationality_id = toInteger(NATIONALITYID),",
						"          employment_status = iif(isNull(STATUS),\"NO\",STATUS),",
						"          effective_start_date = toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          effective_end_date = toTimestamp('9999-12-31 23:59:59'),",
						"          is_current_record = toInteger(1),",
						"          source_created_date = toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          source_updated_date = toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC(),",
						"          etl_batch_id = toLong(0),",
						"          length_regno = length(REGNO)) ~> transform1",
						"transform1 select(skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          employee_key as long,",
						"          source_system_code as string,",
						"          source_employee_id as string,",
						"          company_id as integer,",
						"          employee_code as string,",
						"          registration_number as string,",
						"          family_name as string,",
						"          last_name as string,",
						"          first_name as string,",
						"          gender as string,",
						"          birth_date as date,",
						"          nationality_id as integer,",
						"          employment_status as string,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp,",
						"          etl_batch_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     saveOrder: 1,",
						"     preCommands: [],",
						"     postCommands: []) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/From_Staging_to_DWH_TBLDEPARTMENT')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_TBLDEPARTMENT",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_COMPANY",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_Department",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "joined"
						},
						{
							"name": "derivedclean"
						},
						{
							"name": "scdMark"
						}
					],
					"scriptLines": [
						"parameters{",
						"     cwfolder as string (\"TBLDEPARTMENT\"),",
						"     cwtablename as string (\"dim_department\")",
						"}",
						"source(output(",
						"          DEPID as short,",
						"          DEPCODE as string,",
						"          NAME as string,",
						"          ISACTIVE as boolean,",
						"          PARENTID as string,",
						"          CREATED as string,",
						"          UPDATED as string,",
						"          COMPANYID as string,",
						"          DEPTYPEID as short,",
						"          PATH as string,",
						"          PARENTPATH as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source(output(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"source1, source2 join(COMPANYID == company_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joined",
						"joined derive(source_department_id = toString(DEPID),",
						"          department_code = toString(DEPCODE),",
						"          department_name = trim(NAME),",
						"          department_type_id = DEPTYPEID,",
						"          parent_department_key_raw = trim(PARENTID),",
						"          raw_parent_path = iif(isNull(PARENTPATH) || trim(PARENTPATH) == '', '', trim(PARENTPATH)),",
						"          clean_parent_path = iif(PARENTPATH == '', '', trim(replace(replace(PARENTPATH, '|', '/'), '//', '/'))),",
						"          department_path = iif(isNull(PATH) || trim(PATH) == '', '', trim(replace(replace(PATH, '|', '/'), '//', '/'))),",
						"          is_active_int = iif(ISACTIVE == true(), 1, 0),",
						"          effective_start_date = iif(isNull(CREATED), currentUTC(), toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          effective_end_date = iif(isNull(UPDATED), toTimestamp('9999-12-31T00:00:00Z'), toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC(),",
						"          etl_batch_id = toLong(currentUTC()),",
						"          company_key = company_key,",
						"          company_code = company_code) ~> derivedclean",
						"derivedclean derive(business_hash = md5(concat(",
						"        iifNull(department_code, ''), '|',",
						"        iifNull(department_name, ''), '|',",
						"        iifNull(toString(department_type_id), ''), '|',",
						"        iifNull(parent_department_key_raw, ''), '|',",
						"        iifNull(department_path, ''), '|',",
						"        iifNull(toString(is_active_int), ''), '|',",
						"        iifNull(toString(effective_start_date), ''), '|',",
						"        iifNull(toString(effective_end_date), '')",
						"    ) )) ~> scdMark",
						"scdMark sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          department_key as integer,",
						"          source_system_code as string,",
						"          source_department_id as string,",
						"          company_key as integer,",
						"          department_code as string,",
						"          department_name as string,",
						"          parent_department_key as integer,",
						"          department_level as string,",
						"          is_active as integer,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     upsertKeyColumns: ['source_department_id','company_key']) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/HREmployee_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_Employee",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable1_Employee",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "sourcesystemcode"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as string,",
						"          CODE as string,",
						"          FAMILYNAME as string,",
						"          LASTNAME as string,",
						"          FIRSTNAME as string,",
						"          GENDER as string,",
						"          BIRTHDATE as string,",
						"          BIRTHCOUNTRYID as string,",
						"          BIRTHDIVISIONID as string,",
						"          BIRTHDISTRICTID as string,",
						"          BIRTHPLACE as string,",
						"          COUNTRYID as string,",
						"          DIVISIONID as string,",
						"          DISTRICTID as string,",
						"          NATIONALITYID as string,",
						"          SOCIALORIGINID as string,",
						"          MARITALSTATUS as string,",
						"          BLOODGROUP as string,",
						"          REGNO as string,",
						"          PASSNO as string,",
						"          FORPASSNO as string,",
						"          EMDNO as string,",
						"          NDDNO as string,",
						"          ADDR1 as string,",
						"          ADDR2 as string,",
						"          HOMEPHONE as string,",
						"          MOBILEPHONE as string,",
						"          WORKPHONE as string,",
						"          WORKPHONEEXT as string,",
						"          FAX as string,",
						"          EMAIL as string,",
						"          POSTADDRESS as string,",
						"          CONTACTNAME as string,",
						"          CONTACTPHONE as string,",
						"          WITHPICTURE as string,",
						"          STATUS as string,",
						"          CREATED as string,",
						"          CREATEDBY as string,",
						"          UPDATED as string,",
						"          UPDATEDBY as string,",
						"          IPADDRESS as string,",
						"          MACADDRESS as string,",
						"          TSTAMP as string,",
						"          COMPANYID as string,",
						"          STATUSDATE as string,",
						"          LASTNAMELENGTH as string,",
						"          EMAIL2 as string,",
						"          CONTACTNAME2 as string,",
						"          CONTACTPHONE2 as string,",
						"          ISBLACKLISTED as string,",
						"          BLACKLISTREASON as string,",
						"          BLACKLISTEDDATE as string,",
						"          ISFOREIGNER as string,",
						"          CONTACTID as string,",
						"          MILITARYSERVED as string,",
						"          TRAININGSPORT as string,",
						"          INTEREST as string,",
						"          APPID as string,",
						"          MILITARYNO as string,",
						"          RELATIVEID as string,",
						"          RELATIVEID2 as string,",
						"          MILITARYCLOSETYPE as string,",
						"          MILITARYCOMMENT as string,",
						"          LINKEDIN as string,",
						"          FACEBOOK as string,",
						"          TWITTER as string,",
						"          ISSPYOATH as string,",
						"          SPYOATHDATE as string,",
						"          ISGOVERNMENTOATH as string,",
						"          GOVERNMENTOATHDATE as string,",
						"          ISMILITARYOATH as string,",
						"          MILITARYOATHDATE as string,",
						"          LINKID as string,",
						"          ISRESIDENT as string,",
						"          CIVILID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source1 derive(source_system_code = 0,",
						"          COMPANYID = iif(isNull(COMPANYID), 'MCK', COMPANYID),",
						"          source_employee_id = iif(isNull(EMPID), 'unknown_id', toString(EMPID) )) ~> sourcesystemcode",
						"sourcesystemcode sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          employee_key as long,",
						"          source_system_code as string,",
						"          source_employee_id as string,",
						"          company_id as string,",
						"          employee_code as string,",
						"          registration_number as string,",
						"          family_name as string,",
						"          last_name as string,",
						"          first_name as string,",
						"          gender as string,",
						"          birth_date as date,",
						"          nationality_id as integer,",
						"          employment_status as string,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp,",
						"          etl_batch_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          each(match(/* All input columns */true()),",
						"               /* Input name */$$ = $$)",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SIGRADE_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_SIGRADE",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_Grade",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "transform1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          GRADEID as short,",
						"          CODE as string,",
						"          GRADENO as short,",
						"          NAME as string,",
						"          ISACTIVE as boolean,",
						"          CREATED as string,",
						"          UPDATED as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source1 derive(is_active = 1,",
						"          source_system_code = '0',",
						"          source_created_date = toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          source_updated_date = toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC(),",
						"          grade_id = GRADEID,",
						"          grade_no = GRADENO,",
						"          code = CODE,",
						"          name = NAME) ~> transform1",
						"transform1 select(skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     input(",
						"          grade_key as integer,",
						"          grade_id as integer,",
						"          code as string,",
						"          grade_no as integer,",
						"          name as string,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     saveOrder: 1,",
						"     preCommands: [],",
						"     postCommands: []) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/SILEVEL_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_SILEVEL",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_SILEVEL",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "transform1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          LEVELID as short,",
						"          CODE as string,",
						"          NAME as string,",
						"          ISACTIVE as boolean,",
						"          CREATED as string,",
						"          UPDATED as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source1 derive(source_system_code = '0',",
						"          source_created_date = toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          source_updated_date = toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC(),",
						"          level_id = LEVELID,",
						"          code = CODE,",
						"          is_active = toInteger(1),",
						"          name = NAME) ~> transform1",
						"transform1 sink(allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     input(",
						"          level_key as integer,",
						"          level_id as integer,",
						"          code as string,",
						"          name as string,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     saveOrder: 1) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TBLCOMPANY_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_TBLCOMPANY",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_COMPANY",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "transform1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          COMPANYID as string,",
						"          NAME as string,",
						"          CREATED as string,",
						"          UPDATED as string,",
						"          PARENTID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source1 derive(company_code = COMPANYID,",
						"          company_name = NAME,",
						"          is_active = 1,",
						"          source_system_code = '0',",
						"          source_created_date = toTimestamp(CREATED),",
						"          source_updated_date = toTimestamp(UPDATED),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC()) ~> transform1",
						"transform1 select(mapColumn(",
						"          company_code,",
						"          company_name,",
						"          is_active,",
						"          source_system_code,",
						"          source_created_date,",
						"          source_updated_date,",
						"          dw_created_date,",
						"          dw_updated_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     input(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     saveOrder: 1) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TBLEMPEMPLHIST_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_TBLEMPEMPLHIST",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_EMPLOYEE",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_COMPANY",
								"type": "DatasetReference"
							},
							"name": "source3"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_Department",
								"type": "DatasetReference"
							},
							"name": "source4"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable1_POSITION",
								"type": "DatasetReference"
							},
							"name": "source5"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_Grade",
								"type": "DatasetReference"
							},
							"name": "source6"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_SILEVEL",
								"type": "DatasetReference"
							},
							"name": "source7"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_Fact_employee_hist",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "sourcesystemcode"
						},
						{
							"name": "filter1"
						},
						{
							"name": "joinEmployee"
						},
						{
							"name": "selectEmployee"
						},
						{
							"name": "joinCompany"
						},
						{
							"name": "selectCompany"
						},
						{
							"name": "select4"
						},
						{
							"name": "joinDepartment"
						},
						{
							"name": "selectPosition"
						},
						{
							"name": "joinPosition"
						},
						{
							"name": "select6Grade"
						},
						{
							"name": "selectLevel"
						},
						{
							"name": "joinWithGrade"
						},
						{
							"name": "joinWithLevel"
						}
					],
					"scriptLines": [
						"parameters{",
						"     cwfolder as string (\"TBLEMPEMPLHIST\")",
						"}",
						"source(output(",
						"          HISTORYID as integer,",
						"          EMPID as short,",
						"          BEGINDATE as string,",
						"          ENDDATE as string,",
						"          ORDERID as short,",
						"          ORDERTYPE as string,",
						"          COMPANYID as string,",
						"          DEPID as short,",
						"          POSITIONID as short,",
						"          GRADEID as short,",
						"          LEVELID as short,",
						"          BASEWAGE as integer,",
						"          BASEWAGECURRCODE as string,",
						"          CREATED as string,",
						"          UPDATED as string,",
						"          ORDERNO as string,",
						"          OLDDEPNAME as string,",
						"          JOBID as short,",
						"          INSURETYPEID as short,",
						"          LABOURCONDITION as boolean",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source(output(",
						"          employee_key as long,",
						"          source_system_code as string,",
						"          source_employee_id as string,",
						"          company_id as string,",
						"          employee_code as string,",
						"          registration_number as string,",
						"          family_name as string,",
						"          last_name as string,",
						"          first_name as string,",
						"          gender as string,",
						"          birth_date as date,",
						"          nationality_id as integer,",
						"          employment_status as string,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp,",
						"          etl_batch_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"source(output(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source3",
						"source(output(",
						"          department_key as integer,",
						"          source_system_code as string,",
						"          source_department_id as string,",
						"          company_key as integer,",
						"          department_code as string,",
						"          department_name as string,",
						"          parent_department_key as integer,",
						"          department_level as string,",
						"          is_active as integer,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source4",
						"source(output(",
						"          position_key as integer,",
						"          source_system_code as string,",
						"          source_position_id as string,",
						"          company_key as integer,",
						"          position_code as string,",
						"          position_name as string,",
						"          position_category as string,",
						"          position_level as string,",
						"          is_management as integer,",
						"          is_active as integer,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source5",
						"source(output(",
						"          grade_key as integer,",
						"          grade_id as integer,",
						"          code as string,",
						"          grade_no as integer,",
						"          name as string,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source6",
						"source(output(",
						"          level_key as integer,",
						"          level_id as integer,",
						"          code as string,",
						"          name as string,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source7",
						"joinWithLevel derive(source_system_code = 0,",
						"          is_current_position = true(),",
						"          is_multiple = 1,",
						"          is_active_employment = 1,",
						"          begin_date = toDate(BEGINDATE, 'yyyy-MM-dd'),",
						"          end_date = toDate(ENDDATE, 'yyyy-MM-dd'),",
						"          source_history_id = HISTORYID,",
						"          source_order_id = ORDERID,",
						"          order_type = ORDERTYPE,",
						"          order_number = ORDERNO,",
						"          level_number = LEVELID,",
						"          base_wage = BASEWAGE,",
						"          base_wage_currency = BASEWAGECURRCODE,",
						"          insurance_type_id = INSURETYPEID,",
						"          labour_condition = LABOURCONDITION,",
						"          source_created_date = toTimestamp(CREATED),",
						"          source_updated_date = toTimestamp(UPDATED),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC(),",
						"          etl_batch_id = toLong(currentUTC())) ~> sourcesystemcode",
						"source1 filter(COMPANYID==\"AG\") ~> filter1",
						"filter1, selectEmployee join(toString(EMPID) == source_employee_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinEmployee",
						"source2 select(mapColumn(",
						"          employee_key,",
						"          source_employee_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectEmployee",
						"joinEmployee, selectCompany join(COMPANYID == company_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinCompany",
						"source3 select(mapColumn(",
						"          company_key,",
						"          company_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectCompany",
						"source4 select(mapColumn(",
						"          department_key,",
						"          source_department_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"joinCompany, select4 join(toString(DEPID) == source_department_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinDepartment",
						"source5 select(mapColumn(",
						"          position_key,",
						"          source_system_code,",
						"          source_position_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectPosition",
						"joinDepartment, selectPosition join(toString(POSITIONID) == source_position_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinPosition",
						"source6 select(mapColumn(",
						"          grade_key,",
						"          grade_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6Grade",
						"source7 select(mapColumn(",
						"          level_key,",
						"          level_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectLevel",
						"joinPosition, select6Grade join(GRADEID == grade_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinWithGrade",
						"joinWithGrade, selectLevel join(LEVELID == level_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinWithLevel",
						"sourcesystemcode sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          history_fact_key as long,",
						"          employee_key as long,",
						"          company_key as integer,",
						"          department_key as integer,",
						"          position_key as integer,",
						"          grade_key as integer,",
						"          level_key as integer,",
						"          begin_date as date,",
						"          end_date as date,",
						"          source_system_code as string,",
						"          source_history_id as string,",
						"          source_employee_id as string,",
						"          source_order_id as string,",
						"          order_type as string,",
						"          order_number as string,",
						"          level_number as integer,",
						"          base_wage as decimal(18,2),",
						"          base_wage_currency as string,",
						"          insurance_type_id as integer,",
						"          labour_condition as string,",
						"          is_current_position as integer,",
						"          is_active_employment as integer,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp,",
						"          etl_batch_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     mapColumn(",
						"          employee_key,",
						"          company_key,",
						"          department_key,",
						"          position_key,",
						"          grade_key,",
						"          level_key,",
						"          begin_date,",
						"          end_date,",
						"          source_employee_id,",
						"          order_type = ORDERTYPE,",
						"          order_number = ORDERNO,",
						"          level_number = LEVELID,",
						"          base_wage = BASEWAGE,",
						"          base_wage_currency = BASEWAGECURRCODE,",
						"          insurance_type_id = INSURETYPEID,",
						"          labour_condition = LABOURCONDITION,",
						"          is_current_position,",
						"          is_active_employment,",
						"          source_created_date,",
						"          source_updated_date,",
						"          dw_created_date,",
						"          dw_updated_date,",
						"          etl_batch_id",
						"     ),",
						"     preCommands: [],",
						"     postCommands: []) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TBLPOSITION_From_Staging_to_DWH')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/Mysql"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Staging_TBLPOSITION",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "AzureMySqlTable_COMPANY",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "AzureMySqlTable1_POSITION",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "sourcesystemcode"
						},
						{
							"name": "renamecols"
						},
						{
							"name": "select1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     cwfolder as string (\"TBLPOSITION\"),",
						"     cwtablename as string (\"dim_position\")",
						"}",
						"source(output(",
						"          POSITIONID as short,",
						"          COMPANYID as string,",
						"          DEPID as short,",
						"          POSGROUPID as short,",
						"          CODE as string,",
						"          NAME as string,",
						"          EMPLOYMENTTYPEID as short,",
						"          GRADEID as short,",
						"          VACANCYDAYS as short,",
						"          LABOURCONDITION as string,",
						"          ISACTIVE as boolean,",
						"          CREATED as string,",
						"          UPDATED as string,",
						"          JOBDESCID as short,",
						"          JOBID as short,",
						"          TYPE as string,",
						"          POSITIONOCCID as short,",
						"          POSLEVEL as short",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet') ~> source1",
						"source(output(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"join1 derive(COMPANYID = iif(isNull(COMPANYID), 'MCK', COMPANYID),",
						"          source_system_code = 0,",
						"          ISACTIVE_INT = iif(ISACTIVE, 1, 0),",
						"          company_key = company_key) ~> sourcesystemcode",
						"sourcesystemcode derive(source_position_id = toString(POSITIONID),",
						"          position_code = CODE,",
						"          position_name = NAME,",
						"          position_category = TYPE,",
						"          position_level = toString(POSLEVEL),",
						"          is_management = toInteger(iif(POSLEVEL <= 2, 1, 0)),",
						"          is_active = toInteger(ISACTIVE_INT),",
						"          effective_start_date = iif(isNull(CREATED), currentUTC(), toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          effective_end_date = iif(isNull(UPDATED), toTimestamp('9999-12-31T00:00:00Z'), toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          is_current_record = toInteger(1),",
						"          dw_created_date = currentTimestamp(),",
						"          dw_updated_date = currentTimestamp()) ~> renamecols",
						"renamecols select(mapColumn(",
						"          source_system_code,",
						"          source_position_id,",
						"          company_key,",
						"          position_code,",
						"          position_name,",
						"          position_category,",
						"          position_level,",
						"          is_management,",
						"          is_active,",
						"          effective_start_date,",
						"          effective_end_date,",
						"          is_current_record,",
						"          dw_created_date,",
						"          dw_updated_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"source1, source2 join(COMPANYID == company_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     input(",
						"          position_key as integer,",
						"          source_system_code as string,",
						"          source_position_id as string,",
						"          company_key as integer,",
						"          position_code as string,",
						"          position_name as string,",
						"          position_category as string,",
						"          position_level as string,",
						"          is_management as integer,",
						"          is_active as integer,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as integer,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     saveOrder: 1) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/TD_Customer_Raw_to_Filtered')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "TD"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ADLS_Raw_CSV",
								"type": "DatasetReference"
							},
							"name": "tdRawFullCustomerCSV"
						},
						{
							"dataset": {
								"referenceName": "ADLS_Raw_CSV",
								"type": "DatasetReference"
							},
							"name": "tdRawTradeShopGpsCSV"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ADLS_Filtered_CSV",
								"type": "DatasetReference"
							},
							"name": "tdFilteredCSV"
						}
					],
					"transformations": [
						{
							"name": "TradeShopIDLeftJoin"
						},
						{
							"name": "ColumnFiltering",
							"description": "Renaming and (removing) TradeShopIDLeftJoin to ColumnFiltering with columns"
						}
					],
					"scriptLines": [
						"source(output(",
						"          CusID as integer,",
						"          CusName as string,",
						"          cusAddress as string,",
						"          ISISChannelID as short,",
						"          OwnerID as integer,",
						"          OwnerName as string,",
						"          INN as string,",
						"          StoreTypeName as string,",
						"          Region as string,",
						"          SumNer as string,",
						"          CreateDate as string,",
						"          UpdateDate as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('hash', 1)) ~> tdRawFullCustomerCSV",
						"source(output(",
						"          TradeshopID as integer,",
						"          CreatedDate as string,",
						"          UpdatedDate as string,",
						"          pickpackid as string,",
						"          Longitude as string,",
						"          Latitude as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     partitionBy('hash', 1)) ~> tdRawTradeShopGpsCSV",
						"tdRawFullCustomerCSV, tdRawTradeShopGpsCSV join(CusID == TradeshopID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'off')~> TradeShopIDLeftJoin",
						"TradeShopIDLeftJoin select(mapColumn(",
						"          cusid_td = CusID,",
						"          trade_shop_name = CusName,",
						"          full_address = cusAddress,",
						"          customer_td_id = OwnerID,",
						"          customer_name = OwnerName,",
						"          store_type = StoreTypeName,",
						"          customer_register = INN,",
						"          channel_id = ISISChannelID,",
						"          district = Region,",
						"          khoroo = SumNer,",
						"          customer_created_date = CreateDate,",
						"          longitude = Longitude,",
						"          latitude = Latitude",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ColumnFiltering",
						"ColumnFiltering sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['td_dwh_customer_full.csv'],",
						"     umask: 0775,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> tdFilteredCSV"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ag_customer_to_master')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "AG"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceCC"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceMaster"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceMasterIds"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sinkMaster"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sinkInsertMaster"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sinkMasterIds"
						}
					],
					"transformations": [
						{
							"name": "deriveClean"
						},
						{
							"name": "aggregateDeduplicate"
						},
						{
							"name": "getMaxMasterId"
						},
						{
							"name": "lookupExisting"
						},
						{
							"name": "splitRecords"
						},
						{
							"name": "crossJoinMaxId"
						},
						{
							"name": "generateMasterIds"
						},
						{
							"name": "selectForInsert"
						},
						{
							"name": "selectForUpdate"
						},
						{
							"name": "addRowNumber"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "chooseSource"
						},
						{
							"name": "select1"
						},
						{
							"name": "selectMaster"
						},
						{
							"name": "selectExistMasterIds"
						},
						{
							"name": "join1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join2"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as integer,",
						"          customer_ag_id as integer,",
						"          customer_name as string,",
						"          full_address as string,",
						"          golden_flag as boolean,",
						"          customer_register as string,",
						"          register_type as boolean,",
						"          phone_number as string,",
						"          customer_created_date as timestamp,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          is_reliable_register as boolean",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceCC",
						"source(output(",
						"          id as integer,",
						"          customer_master_id as integer,",
						"          customer_master_id_prime as integer,",
						"          customer_register as string,",
						"          register_type as integer,",
						"          golden_flag as string,",
						"          customer_name as string,",
						"          full_address as string,",
						"          phone_number as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          customer_created_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceMaster",
						"source(output(",
						"          id as integer,",
						"          customer_master_id as integer,",
						"          customer_cc_id as integer,",
						"          customer_ag_id as integer,",
						"          customer_td_id as integer,",
						"          created_at as timestamp,",
						"          updated_at as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceMasterIds",
						"sourceCC derive(customer_register = upper(\r",
						"    replace(\r",
						"        trim(customer_register),\r",
						"        ' ',\r",
						"        ''\r",
						"    )\r",
						"),",
						"          customer_name = iif(\r",
						"    /* CASE 1: Starts with 5+ digits */\r",
						"    regexMatch(trim(customer_name), '^[0-9]{5,}.*'),\r",
						"    trim(\r",
						"        regexReplace(\r",
						"            trim(customer_name),\r",
						"            '^[0-9]+[^0-9]?',\r",
						"            ''\r",
						"        )\r",
						"    ),\r",
						"\r",
						"    /* ELSE CASE 2: Ends with 5+ digits */\r",
						"    iif(\r",
						"        regexMatch(trim(customer_name), '.*[0-9]{5,}$'),\r",
						"        trim(\r",
						"            regexReplace(\r",
						"                trim(customer_name),\r",
						"                '[^0-9]?[0-9]+$',\r",
						"                ''\r",
						"            )\r",
						"        ),\r",
						"\r",
						"        /* ELSE: leave as is */\r",
						"        trim(customer_name)\r",
						"    )\r",
						"),",
						"          full_address = trim(full_address),",
						"          golden_flag = iif(isNull(golden_flag) , 'N', 'Y'),",
						"          phone_number = regexReplace(phone_number, '[^0-9]', ''),",
						"          phone_flag = iif(length(regexReplace(phone_number, '[^0-9]', '')) == 8, 1, 0),",
						"          register_type = iif(register_type, 1, 0)) ~> deriveClean",
						"deriveClean aggregate(groupBy(customer_register),",
						"     id = first(id),",
						"          is_reliable_register = max(is_reliable_register),",
						"          phone_number_cc = last(phone_number),",
						"          register_type = toInteger(max(register_type)),",
						"          full_address_cc = last(full_address),",
						"          customer_name_cc = max(customer_name),",
						"          golden_flag = last(golden_flag),",
						"          golden_flag_cc = last(golden_flag),",
						"          customer_created_date = min(customer_created_date),",
						"          created_at = max(created_at),",
						"          updated_at = max(updated_at)) ~> aggregateDeduplicate",
						"selectMaster aggregate(max_customer_master_id = max(customer_master_id_ms)) ~> getMaxMasterId",
						"select1, selectMaster join(customer_register_sc == customer_register_ms,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> lookupExisting",
						"lookupExisting split(isNull(customer_register_ms),",
						"     disjoint: false) ~> splitRecords@(newRecords, existingRecords)",
						"addRowNumber, getMaxMasterId join(true(),",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'right')~> crossJoinMaxId",
						"crossJoinMaxId derive(customer_master_id_created = coalesce(max_customer_master_id, toLong(0)) + toLong(row_num),",
						"          customer_master_id_prime_created = mod((12534191 * (coalesce(max_customer_master_id, toLong(0)) + toLong(row_num)) + 12534217), 100000000)) ~> generateMasterIds",
						"generateMasterIds select(mapColumn(",
						"          customer_master_id = customer_master_id_created,",
						"          customer_master_id_prime = customer_master_id_prime_created,",
						"          customer_register = customer_register_sc,",
						"          register_type = register_type_sc,",
						"          golden_flag = golden_flag_sc,",
						"          customer_name = customer_name_sc,",
						"          full_address = full_address_sc,",
						"          phone_number = phone_number_sc,",
						"          phone_number_flag = phone_number_sc,",
						"          customer_created_date = customer_created_date_sc,",
						"          created_at = created_at_sc,",
						"          updated_at = updated_at_sc,",
						"          is_reliable_register = is_reliable_register_sc",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectForInsert",
						"chooseSource select(mapColumn(",
						"          id = id_ms,",
						"          customer_master_id,",
						"          customer_master_id_prime,",
						"          customer_register = customer_register_ms,",
						"          register_type = register_type_ms,",
						"          golden_flag = golden_flag_final,",
						"          customer_name = customer_name_final,",
						"          full_address = full_address_final,",
						"          phone_number = phone_number_final,",
						"          phone_number_flag = phone_number_final,",
						"          customer_created_date = customer_created_date_final,",
						"          created_at = created_at_final,",
						"          updated_at = updated_at_final",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectForUpdate",
						"splitRecords@newRecords window(asc(customer_register_sc, true),",
						"     row_num = rowNumber()) ~> addRowNumber",
						"selectForUpdate alterRow(updateIf(true())) ~> AlterRow1",
						"splitRecords@existingRecords derive(phone_number_final = iif(\r",
						"    isNull(phone_number_ms) ||\r",
						"    length(regexReplace(toString(phone_number_ms), '[^0-9]', '')) != 8 ||\r",
						"    not(regexMatch(regexReplace(toString(phone_number_ms), '[^0-9]', ''), '^[0-9]{8}$')) ||\r",
						"    in(['00000000','11111111','22222222','33333333','44444444',\r",
						"         '55555555','66666666','77777777','88888888','99999999'],regexReplace(toString(phone_number_ms), '[^0-9]', '')\r",
						"    ),\r",
						"    phone_number_sc,\r",
						"    phone_number_ms\r",
						"),",
						"          full_address_final = iif(isNull(full_address_ms) || toString(full_address_ms) == '' || length(full_address_ms)<length(full_address_sc), full_address_sc, full_address_ms),",
						"          customer_name_final = iif(isNull(customer_name_ms) || toString(customer_name_ms) == '' || length(customer_name_ms)<length(customer_name_sc), customer_name_sc, customer_name_ms),",
						"          golden_flag_final = iif(isNull(golden_flag_ms) || toString(golden_flag_ms) == '' , golden_flag_sc, golden_flag_ms),",
						"          customer_created_date_final = iif(isNull(customer_created_date_ms) || customer_created_date_sc<customer_created_date_ms, customer_created_date_sc,customer_created_date_ms),",
						"          created_at_final = iif(isNull(created_at_ms) || created_at_ms<created_at_sc, created_at_sc,created_at_ms),",
						"          updated_at_final = iif(isNull(updated_at_ms) || updated_at_sc>updated_at_ms, updated_at_sc,updated_at_ms),",
						"          customer_master_id = customer_master_id_ms,",
						"          customer_master_id_prime = customer_master_id_prime_ms,",
						"          register_type = iif(!isNull(customer_register_ms) && length(customer_register_ms) == 7 && regexMatch(customer_register_ms, '^[0-9]{7}$'), 1,",
						"    iif(!isNull(customer_register_ms) && length(customer_register_ms) == 10 && regexMatch(customer_register_ms, '^[A-Za-z]{2}[0-9]{8}$'), 0, toInteger(2)))) ~> chooseSource",
						"aggregateDeduplicate select(mapColumn(",
						"          customer_register_sc = customer_register,",
						"          id_sc = id,",
						"          is_reliable_register_sc = is_reliable_register,",
						"          phone_number_sc = phone_number_cc,",
						"          register_type_sc = register_type,",
						"          full_address_sc = full_address_cc,",
						"          customer_name_sc = customer_name_cc,",
						"          golden_flag_sc = golden_flag_cc,",
						"          customer_created_date_sc = customer_created_date,",
						"          created_at_sc = created_at,",
						"          updated_at_sc = updated_at",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"sourceMaster select(mapColumn(",
						"          id_ms = id,",
						"          customer_master_id_ms = customer_master_id,",
						"          customer_master_id_prime_ms = customer_master_id_prime,",
						"          customer_register_ms = customer_register,",
						"          register_type_ms = register_type,",
						"          golden_flag_ms = golden_flag,",
						"          customer_name_ms = customer_name,",
						"          full_address_ms = full_address,",
						"          phone_number_ms = phone_number,",
						"          created_at_ms = created_at,",
						"          updated_at_ms = updated_at,",
						"          customer_created_date_ms = customer_created_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectMaster",
						"sourceMasterIds select(mapColumn(",
						"          customer_master_id_ms = customer_master_id,",
						"          customer_ag_id_ms = customer_ag_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectExistMasterIds",
						"select3, selectExistMasterIds join(customer_ag_id_scs == customer_ag_id_ms,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 filter(isNull(customer_master_id_ms)) ~> filter1",
						"filter1, selectForInsert join(customer_register_scs == customer_register,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2 select(mapColumn(",
						"          customer_ag_id = customer_ag_id_scs,",
						"          created_at = created_at_scs,",
						"          updated_at = updated_at_scs,",
						"          customer_master_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"deriveClean select(mapColumn(",
						"          customer_ag_id_scs = customer_ag_id,",
						"          customer_register_scs = customer_register,",
						"          customer_created_date_scs = customer_created_date,",
						"          created_at_scs = created_at,",
						"          updated_at_scs = updated_at",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkMaster",
						"selectForInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkInsertMaster",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkMasterIds"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/cc_customer_to_master')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "CC"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceCC"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceMaster"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceMasterIds"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sinkMaster"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sinkInsertMaster"
						},
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sinkMasterIds"
						}
					],
					"transformations": [
						{
							"name": "deriveClean"
						},
						{
							"name": "aggregateDeduplicate"
						},
						{
							"name": "getMaxMasterId"
						},
						{
							"name": "lookupExisting"
						},
						{
							"name": "splitRecords"
						},
						{
							"name": "crossJoinMaxId"
						},
						{
							"name": "generateMasterIds"
						},
						{
							"name": "selectForInsert"
						},
						{
							"name": "selectForUpdate"
						},
						{
							"name": "addRowNumber"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "chooseSource"
						},
						{
							"name": "select1"
						},
						{
							"name": "selectMaster"
						},
						{
							"name": "selectExistMasterIds"
						},
						{
							"name": "join1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join2"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as integer,",
						"          customer_cc_id as integer,",
						"          customer_register as string,",
						"          is_reliable_register as integer,",
						"          customer_name as string,",
						"          full_address as string,",
						"          golden_flag as string,",
						"          register_type as integer,",
						"          phone_number as string,",
						"          customer_created_date as timestamp,",
						"          created_at as timestamp,",
						"          updated_at as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceCC",
						"source(output(",
						"          id as integer,",
						"          customer_master_id as integer,",
						"          customer_master_id_prime as integer,",
						"          customer_register as string,",
						"          register_type as integer,",
						"          golden_flag as string,",
						"          customer_name as string,",
						"          full_address as string,",
						"          phone_number as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          customer_created_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceMaster",
						"source(output(",
						"          id as integer,",
						"          customer_master_id as integer,",
						"          customer_cc_id as integer,",
						"          customer_ag_id as integer,",
						"          customer_td_id as integer,",
						"          created_at as timestamp,",
						"          updated_at as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceMasterIds",
						"sourceCC derive(customer_register = upper(\r",
						"    replace(\r",
						"        trim(customer_register),\r",
						"        ' ',\r",
						"        ''\r",
						"    )\r",
						"),",
						"          customer_name = iif(\r",
						"    /* CASE 1: Starts with 5+ digits */\r",
						"    regexMatch(trim(customer_name), '^[0-9]{5,}.*'),\r",
						"    trim(\r",
						"        regexReplace(\r",
						"            trim(customer_name),\r",
						"            '^[0-9]+[^0-9]?',\r",
						"            ''\r",
						"        )\r",
						"    ),\r",
						"\r",
						"    /* ELSE CASE 2: Ends with 5+ digits */\r",
						"    iif(\r",
						"        regexMatch(trim(customer_name), '.*[0-9]{5,}$'),\r",
						"        trim(\r",
						"            regexReplace(\r",
						"                trim(customer_name),\r",
						"                '[^0-9]?[0-9]+$',\r",
						"                ''\r",
						"            )\r",
						"        ),\r",
						"\r",
						"        /* ELSE: leave as is */\r",
						"        trim(customer_name)\r",
						"    )\r",
						"),",
						"          full_address = trim(full_address),",
						"          golden_flag = iif(isNull(golden_flag) || golden_flag == '', 'N', golden_flag),",
						"          phone_number = regexReplace(phone_number, '[^0-9]', ''),",
						"          phone_flag = iif(length(regexReplace(phone_number, '[^0-9]', '')) == 8, 1, 0)) ~> deriveClean",
						"deriveClean aggregate(groupBy(customer_register),",
						"     id = first(id),",
						"          is_reliable_register = max(is_reliable_register),",
						"          phone_number_cc = last(phone_number),",
						"          register_type = max(register_type),",
						"          full_address_cc = last(full_address),",
						"          customer_name_cc = max(customer_name),",
						"          golden_flag = last(golden_flag),",
						"          golden_flag_cc = last(golden_flag),",
						"          customer_created_date = min(customer_created_date),",
						"          created_at = max(created_at),",
						"          updated_at = max(updated_at)) ~> aggregateDeduplicate",
						"selectMaster aggregate(max_customer_master_id = max(customer_master_id_ms)) ~> getMaxMasterId",
						"select1, selectMaster join(customer_register_sc == customer_register_ms,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> lookupExisting",
						"lookupExisting split(isNull(customer_register_ms),",
						"     disjoint: false) ~> splitRecords@(newRecords, existingRecords)",
						"addRowNumber, getMaxMasterId join(true(),",
						"     joinType:'cross',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'right')~> crossJoinMaxId",
						"crossJoinMaxId derive(customer_master_id_created = coalesce(max_customer_master_id, toLong(0)) + toLong(row_num),",
						"          customer_master_id_prime_created = mod((12534191 * (coalesce(max_customer_master_id, toLong(0)) + toLong(row_num)) + 12534217), 100000000)) ~> generateMasterIds",
						"generateMasterIds select(mapColumn(",
						"          customer_master_id = customer_master_id_created,",
						"          customer_master_id_prime = customer_master_id_prime_created,",
						"          customer_register = customer_register_sc,",
						"          register_type = register_type_sc,",
						"          golden_flag = golden_flag_sc,",
						"          customer_name = customer_name_sc,",
						"          full_address = full_address_sc,",
						"          phone_number = phone_number_sc,",
						"          phone_number_flag = phone_number_sc,",
						"          customer_created_date = customer_created_date_sc,",
						"          created_at = created_at_sc,",
						"          updated_at = updated_at_sc,",
						"          is_reliable_register = is_reliable_register_sc",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectForInsert",
						"chooseSource select(mapColumn(",
						"          id = id_ms,",
						"          customer_master_id,",
						"          customer_master_id_prime,",
						"          customer_register = customer_register_ms,",
						"          register_type = register_type_ms,",
						"          golden_flag = golden_flag_final,",
						"          customer_name = customer_name_final,",
						"          full_address = full_address_final,",
						"          phone_number = phone_number_final,",
						"          phone_number_flag = phone_number_final,",
						"          customer_created_date = customer_created_date_final,",
						"          created_at = created_at_final,",
						"          updated_at = updated_at_final",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectForUpdate",
						"splitRecords@newRecords window(asc(customer_register_sc, true),",
						"     row_num = rowNumber()) ~> addRowNumber",
						"selectForUpdate alterRow(updateIf(true())) ~> AlterRow1",
						"splitRecords@existingRecords derive(phone_number_final = iif(\r",
						"    isNull(phone_number_ms) ||\r",
						"    length(regexReplace(toString(phone_number_ms), '[^0-9]', '')) != 8 ||\r",
						"    not(regexMatch(regexReplace(toString(phone_number_ms), '[^0-9]', ''), '^[0-9]{8}$')) ||\r",
						"    in(['00000000','11111111','22222222','33333333','44444444',\r",
						"         '55555555','66666666','77777777','88888888','99999999'],regexReplace(toString(phone_number_ms), '[^0-9]', '')\r",
						"    ),\r",
						"    phone_number_sc,\r",
						"    phone_number_ms\r",
						"),",
						"          full_address_final = iif(isNull(full_address_ms) || toString(full_address_ms) == '' || length(full_address_ms)<length(full_address_sc), full_address_sc, full_address_ms),",
						"          customer_name_final = iif(isNull(customer_name_ms) || toString(customer_name_ms) == '' || length(customer_name_ms)<length(customer_name_sc), customer_name_sc, customer_name_ms),",
						"          golden_flag_final = iif(isNull(golden_flag_ms) || toString(golden_flag_ms) == '' , golden_flag_sc, golden_flag_ms),",
						"          customer_created_date_final = iif(isNull(customer_created_date_ms) || customer_created_date_sc<customer_created_date_ms, customer_created_date_sc,customer_created_date_ms),",
						"          created_at_final = iif(isNull(created_at_ms) || created_at_ms<created_at_sc, created_at_sc,created_at_ms),",
						"          updated_at_final = iif(isNull(updated_at_ms) || updated_at_sc>updated_at_ms, updated_at_sc,updated_at_ms),",
						"          customer_master_id = customer_master_id_ms,",
						"          customer_master_id_prime = customer_master_id_prime_ms,",
						"          register_type = iif(!isNull(customer_register_ms) && length(customer_register_ms) == 7 && regexMatch(customer_register_ms, '^[0-9]{7}$'), 1,",
						"    iif(!isNull(customer_register_ms) && length(customer_register_ms) == 10 && regexMatch(customer_register_ms, '^[A-Za-z]{2}[0-9]{8}$'), 0, toInteger(null())))) ~> chooseSource",
						"aggregateDeduplicate select(mapColumn(",
						"          customer_register_sc = customer_register,",
						"          id_sc = id,",
						"          is_reliable_register_sc = is_reliable_register,",
						"          phone_number_sc = phone_number_cc,",
						"          register_type_sc = register_type,",
						"          full_address_sc = full_address_cc,",
						"          customer_name_sc = customer_name_cc,",
						"          golden_flag_sc = golden_flag_cc,",
						"          customer_created_date_sc = customer_created_date,",
						"          created_at_sc = created_at,",
						"          updated_at_sc = updated_at",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"sourceMaster select(mapColumn(",
						"          id_ms = id,",
						"          customer_master_id_ms = customer_master_id,",
						"          customer_master_id_prime_ms = customer_master_id_prime,",
						"          customer_register_ms = customer_register,",
						"          register_type_ms = register_type,",
						"          golden_flag_ms = golden_flag,",
						"          customer_name_ms = customer_name,",
						"          full_address_ms = full_address,",
						"          phone_number_ms = phone_number,",
						"          created_at_ms = created_at,",
						"          updated_at_ms = updated_at,",
						"          customer_created_date_ms = customer_created_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectMaster",
						"sourceMasterIds select(mapColumn(",
						"          customer_master_id_ms = customer_master_id,",
						"          customer_cc_id_ms = customer_cc_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectExistMasterIds",
						"select3, selectExistMasterIds join(customer_cc_id_scs == customer_cc_id_ms,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 filter(isNull(customer_master_id_ms)) ~> filter1",
						"filter1, selectForInsert join(customer_register_scs == customer_register,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2 select(mapColumn(",
						"          customer_cc_id = customer_cc_id_scs,",
						"          created_at = created_at_scs,",
						"          updated_at = updated_at_scs,",
						"          customer_master_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"deriveClean select(mapColumn(",
						"          customer_cc_id_scs = customer_cc_id,",
						"          customer_register_scs = customer_register,",
						"          customer_created_date_scs = customer_created_date,",
						"          created_at_scs = created_at,",
						"          updated_at_scs = updated_at",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkMaster",
						"selectForInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkInsertMaster",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sinkMasterIds"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/cc_customer_to_master_test')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "CC"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dwh_Sql",
								"type": "DatasetReference"
							},
							"name": "sourceCC"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ADLS_Raw_CSV",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "select1"
						},
						{
							"name": "maxs"
						}
					],
					"scriptLines": [
						"source(output(",
						"          id as integer,",
						"          customer_cc_id as integer,",
						"          customer_register as string,",
						"          is_reliable_register as integer,",
						"          customer_name as string,",
						"          full_address as string,",
						"          golden_flag as string,",
						"          register_type as integer,",
						"          phone_number as string,",
						"          customer_created_date as timestamp,",
						"          created_at as timestamp,",
						"          updated_at as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceCC",
						"sourceCC select(skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 aggregate(groupBy(customer_register),",
						"     is_reliable_register = max(is_reliable_register),",
						"          phone_number = max(phone_number),",
						"          register_type = max(register_type),",
						"          full_address = last(full_address),",
						"          customer_name = min(customer_name),",
						"          customer_created_date = min(customer_created_date),",
						"          created_at = last(created_at),",
						"          updated_at = last(updated_at),",
						"          id = max(id)) ~> maxs",
						"maxs sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_evs_allemployee')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/EVS"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Evs_csv",
								"type": "DatasetReference"
							},
							"name": "sourceEmployees"
						},
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "existingAllSources"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "insertNewEmployees",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService_err",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "ADLS_Raw_CSV",
								"type": "DatasetReference"
							},
							"name": "archiveToDataLake"
						}
					],
					"transformations": [
						{
							"name": "transformStatusAndSource"
						},
						{
							"name": "removeDuplicatesInSource"
						},
						{
							"name": "extractNumberFromGname"
						},
						{
							"name": "joinWithAllExisting"
						},
						{
							"name": "filterOnlyNewEmployees"
						},
						{
							"name": "selectAllSourcesKeys"
						},
						{
							"name": "markForInsert"
						}
					],
					"scriptLines": [
						"source(output(",
						"          fn as string,",
						"          ln as string,",
						"          rn as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          status as string,",
						"          empid as integer,",
						"          status_date as timestamp,",
						"          is_foreigner as boolean",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false) ~> sourceEmployees",
						"source(output(",
						"          rn as string,",
						"          oid as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT DISTINCT rn, oid FROM employee_profile_temp',",
						"     format: 'query') ~> existingAllSources",
						"sourceEmployees derive(status = iif(status == 'Идэвхтэй', 1,",
						"            iif(status == 'Ажлаас Гарсан', 2,",
						"                iif(status == 'Шилжсэн', 2,",
						"                    iif(status == 'Түр Эзгүй', 3, toInteger(null()))))),",
						"          is_foreigner = iif(is_foreigner == true(), 1, 0),",
						"          source = 0,",
						"          rn = trim(toString(rn)),",
						"          oid = trim(toString(oid))) ~> transformStatusAndSource",
						"extractNumberFromGname aggregate(groupBy(rn,",
						"          oid),",
						"     fn = last(fn),",
						"          ln = last(ln),",
						"          po = last(po),",
						"          gname = last(gname),",
						"          status = last(status),",
						"          empid = last(empid),",
						"          status_date = max(status_date),",
						"          is_foreigner = last(is_foreigner),",
						"          source = last(source),",
						"          gname_number = last(gname_number)) ~> removeDuplicatesInSource",
						"transformStatusAndSource derive(gname_number = toInteger(regexReplace(gname, '[^0-9]', ''))) ~> extractNumberFromGname",
						"removeDuplicatesInSource, selectAllSourcesKeys join(rn == existing_rn",
						"     && oid == existing_oid,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinWithAllExisting",
						"joinWithAllExisting filter(isNull(existing_rn)) ~> filterOnlyNewEmployees",
						"existingAllSources select(mapColumn(",
						"          existing_rn = rn,",
						"          existing_oid = oid",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectAllSourcesKeys",
						"filterOnlyNewEmployees alterRow(insertIf(true())) ~> markForInsert",
						"markForInsert sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          fn as string,",
						"          rn as string,",
						"          ln as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          empid as integer,",
						"          im as string,",
						"          source as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          status_date as timestamp,",
						"          status as integer,",
						"          gname_number as integer,",
						"          is_foreigner as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     preSQLs:['DELETE FROM employee_profile_temp WHERE source = 0 OR source = \\'0\\''],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> insertNewEmployees",
						"joinWithAllExisting sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['employee_monthly_load.csv'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> archiveToDataLake"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_evs_allemployee_upsert')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/EVS"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Evs_csv",
								"type": "DatasetReference"
							},
							"name": "sourceEmployees"
						},
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "existingAllSources"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Evs_employee",
								"type": "DatasetReference"
							},
							"name": "upsertEmployees"
						},
						{
							"dataset": {
								"referenceName": "ADLS_Raw_Evs_csv",
								"type": "DatasetReference"
							},
							"name": "archiveToDataLake"
						},
						{
							"dataset": {
								"referenceName": "ADLS_Raw_Evs_csv",
								"type": "DatasetReference"
							},
							"name": "logSkippedMigrated"
						}
					],
					"transformations": [
						{
							"name": "transformStatusAndSource"
						},
						{
							"name": "removeDuplicatesInSource"
						},
						{
							"name": "joinWithSource"
						},
						{
							"name": "skipStream"
						},
						{
							"name": "existingAlls"
						},
						{
							"name": "markForInsert"
						},
						{
							"name": "markForUpdate"
						},
						{
							"name": "combinedStream"
						}
					],
					"scriptLines": [
						"source(output(",
						"          fn as string,",
						"          ln as string,",
						"          rn as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          status as string,",
						"          empid as integer,",
						"          status_date as timestamp,",
						"          is_foreigner as boolean",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> sourceEmployees",
						"source(output(",
						"          rn as string,",
						"          oid as string,",
						"          source as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT DISTINCT rn, oid, source FROM employee_profile',",
						"     format: 'query') ~> existingAllSources",
						"sourceEmployees derive(status = iif(status == 'Идэвхтэй', 1, iif(status == 'Ажлаас Гарсан', 2, iif(status == 'Шилжсэн', 2, iif(status == 'Түр Эзгүй', 3, toInteger(null()))))),",
						"          is_foreigner = iif(is_foreigner == true(), 1, 0),",
						"          source = 0,",
						"          rn = trim(toString(rn)),",
						"          oid = trim(toString(oid)),",
						"          gname_number = toInteger(regexReplace(gname, '[^0-9]', ''))) ~> transformStatusAndSource",
						"transformStatusAndSource aggregate(groupBy(rn,",
						"          oid),",
						"     fn = last(fn),",
						"          ln = last(ln),",
						"          po = last(po),",
						"          gname = last(gname),",
						"          status = last(status),",
						"          empid = last(empid),",
						"          status_date = max(status_date),",
						"          is_foreigner = last(is_foreigner),",
						"          source = last(source),",
						"          gname_number = last(gname_number)) ~> removeDuplicatesInSource",
						"removeDuplicatesInSource, existingAlls join(rn == existing_rn",
						"     && oid == existing_oid,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinWithSource",
						"joinWithSource split(isNull(existing_rn),",
						"     !isNull(existing_rn) && existing_source == 0,",
						"     disjoint: false) ~> skipStream@(insertStream, updateStream, skipStream)",
						"existingAllSources select(mapColumn(",
						"          existing_rn = rn,",
						"          existing_oid = oid,",
						"          existing_source = source",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> existingAlls",
						"skipStream@insertStream alterRow(insertIf(true())) ~> markForInsert",
						"skipStream@updateStream alterRow(updateIf(true())) ~> markForUpdate",
						"markForInsert, markForUpdate union(byName: true)~> combinedStream",
						"combinedStream sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          id as integer,",
						"          fn as string,",
						"          rn as string,",
						"          ln as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          empid as integer,",
						"          im as string,",
						"          source as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          status_date as timestamp,",
						"          status as integer,",
						"          gname_number as integer,",
						"          is_foreigner as integer",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['rn','oid','source'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> upsertEmployees",
						"markForUpdate sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          fn as string,",
						"          ln as string,",
						"          rn as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          status as string,",
						"          empid as string,",
						"          status_date as string,",
						"          is_foreigner as string",
						"     ),",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> archiveToDataLake",
						"skipStream@skipStream sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          fn as string,",
						"          ln as string,",
						"          rn as string,",
						"          oid as string,",
						"          po as string,",
						"          gname as string,",
						"          status as string,",
						"          empid as string,",
						"          status_date as string,",
						"          is_foreigner as string",
						"     ),",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> logSkippedMigrated"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dwh_df_company')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/AzureSqlDw"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dataset_Sink",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService_err",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "transform1"
						},
						{
							"name": "select1"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          COMPANYID as string,",
						"          NAME as string,",
						"          ADDRESS as string,",
						"          CREATED as string,",
						"          CREATEDBY as string,",
						"          UPDATED as string,",
						"          UPDATEDBY as string,",
						"          IPADDRESS as string,",
						"          MACADDRESS as string,",
						"          TSTAMP as timestamp,",
						"          BUSINESSTYPEID as long,",
						"          PARENTID as string,",
						"          REPGROUPID as string,",
						"          PHONE as string,",
						"          FAX as string,",
						"          INTCOMPANYID as long,",
						"          JDECOMPANY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source1 derive(company_code = COMPANYID,",
						"          company_name = NAME,",
						"          is_active = 1,",
						"          source_system_code = '0',",
						"          source_created_date = toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          source_updated_date = toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC()) ~> transform1",
						"transform1 select(mapColumn(",
						"          company_code,",
						"          company_name,",
						"          is_active,",
						"          source_system_code,",
						"          source_created_date,",
						"          source_updated_date,",
						"          dw_created_date,",
						"          dw_updated_date",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 alterRow(upsertIf(!isNull(company_code))) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['company_code'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dwh_df_department')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/AzureSqlDw"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dataset_Sink",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService_err",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "sourcesystemcode"
						},
						{
							"name": "select1"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          DEPID as string,",
						"          DEPCODE as string,",
						"          NAME as string,",
						"          ISACTIVE as string,",
						"          PARENTID as string,",
						"          CREATED as string,",
						"          CREATEDBY as string,",
						"          UPDATED as string,",
						"          UPDATEDBY as string,",
						"          IPADDRESS as string,",
						"          MACADDRESS as string,",
						"          TSTAMP as timestamp,",
						"          COMPANYID as string,",
						"          DEPTYPEID as long,",
						"          PATH as string,",
						"          PARENTPATH as string,",
						"          REPGROUPID as string,",
						"          INTDEPID as long,",
						"          INTPARENTID as long,",
						"          DEPTYPE as string,",
						"          LDAPPATH as string,",
						"          ISPROVINCE as string,",
						"          ESTABLISHEDDATE as string,",
						"          SHOWONORGCHART as string,",
						"          FAPURPOSEID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"source1, source2 join(COMPANYID == company_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(COMPANYID = iif(isNull(COMPANYID), 'MCK', COMPANYID),",
						"          source_system_code = 0,",
						"          ISACTIVE_INT = iif(ISACTIVE=='Y', 1, 0),",
						"          company_key = company_key,",
						"          source_department_id = DEPID,",
						"          department_code = DEPCODE,",
						"          department_name = NAME) ~> sourcesystemcode",
						"sourcesystemcode derive(is_active = toInteger(ISACTIVE_INT),",
						"          effective_start_date = iif(isNull(CREATED), currentUTC(), toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          effective_end_date = iif(isNull(UPDATED), toTimestamp('9999-12-31T00:00:00Z'), toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          is_current_record = toInteger(1),",
						"          dw_created_date = currentTimestamp(),",
						"          dw_updated_date = currentTimestamp()) ~> select1",
						"select1 alterRow(upsertIf(!isNull(source_department_id))) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['source_department_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dwh_df_employee')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/AzureSqlDw"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dataset_Sink",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService_err",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "sourcesystemcode"
						},
						{
							"name": "select1"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          EMPID as decimal(20,0),",
						"          CODE as string,",
						"          FAMILYNAME as string,",
						"          LASTNAME as string,",
						"          FIRSTNAME as string,",
						"          GENDER as string,",
						"          BIRTHDATE as string,",
						"          BIRTHCOUNTRYID as long,",
						"          BIRTHDIVISIONID as long,",
						"          BIRTHDISTRICTID as long,",
						"          BIRTHPLACE as string,",
						"          COUNTRYID as long,",
						"          DIVISIONID as long,",
						"          DISTRICTID as long,",
						"          NATIONALITYID as long,",
						"          SOCIALORIGINID as long,",
						"          MARITALSTATUS as string,",
						"          BLOODGROUP as string,",
						"          REGNO as string,",
						"          PASSNO as string,",
						"          FORPASSNO as string,",
						"          EMDNO as string,",
						"          NDDNO as string,",
						"          ADDR1 as string,",
						"          ADDR2 as string,",
						"          HOMEPHONE as string,",
						"          MOBILEPHONE as string,",
						"          WORKPHONE as string,",
						"          WORKPHONEEXT as string,",
						"          FAX as string,",
						"          EMAIL as string,",
						"          POSTADDRESS as string,",
						"          CONTACTNAME as string,",
						"          CONTACTPHONE as string,",
						"          WITHPICTURE as string,",
						"          STATUS as string,",
						"          CREATED as string,",
						"          CREATEDBY as string,",
						"          UPDATED as string,",
						"          UPDATEDBY as string,",
						"          IPADDRESS as string,",
						"          MACADDRESS as string,",
						"          TSTAMP as timestamp,",
						"          COMPANYID as string,",
						"          STATUSDATE as string,",
						"          LASTNAMELENGTH as decimal(38,0),",
						"          EMAIL2 as string,",
						"          CONTACTNAME2 as string,",
						"          CONTACTPHONE2 as string,",
						"          ISBLACKLISTED as string,",
						"          BLACKLISTREASON as string,",
						"          BLACKLISTEDDATE as string,",
						"          ISFOREIGNER as string,",
						"          CONTACTID as long,",
						"          MILITARYSERVED as string,",
						"          TRAININGSPORT as string,",
						"          INTEREST as string,",
						"          APPID as long,",
						"          MILITARYNO as string,",
						"          RELATIVEID as long,",
						"          RELATIVEID2 as long,",
						"          MILITARYCLOSETYPE as string,",
						"          MILITARYCOMMENT as string,",
						"          LINKEDIN as string,",
						"          FACEBOOK as string,",
						"          TWITTER as string,",
						"          ISSPYOATH as string,",
						"          SPYOATHDATE as string,",
						"          ISGOVERNMENTOATH as string,",
						"          GOVERNMENTOATHDATE as string,",
						"          ISMILITARYOATH as string,",
						"          MILITARYOATHDATE as string,",
						"          LINKID as string,",
						"          ISRESIDENT as string,",
						"          CIVILID as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"source1, source2 join(COMPANYID == company_code,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(COMPANYID = iif(isNull(COMPANYID), 'MCK', COMPANYID),",
						"          source_system_code = 0,",
						"          company_key = company_key,",
						"          source_employee_id = EMPID,",
						"          employee_code = CODE,",
						"          registration_number = REGNO,",
						"          family_name = FAMILYNAME,",
						"          last_name = LASTNAME,",
						"          first_name = FIRSTNAME,",
						"          gender = GENDER,",
						"          birth_date = toTimestamp(BIRTHDATE, 'yyyy.MM.dd'),",
						"          nationality_id = NATIONALITYID,",
						"          employment_status = STATUS) ~> sourcesystemcode",
						"sourcesystemcode derive(effective_start_date = iif(         isNull(CREATED) || trim(CREATED)=='' || CREATED=='0000-00-00 00:00:00',         currentUTC(),         toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss')     ),",
						"          effective_end_date = iif(isNull(UPDATED) || trim(UPDATED)=='' || UPDATED=='0000-00-00 00:00:00',         toTimestamp('9999-12-31 23:59:59', 'yyyy-MM-dd HH:mm:ss'),         toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss')     ),",
						"          is_current_record = toInteger(1),",
						"          dw_created_date = currentTimestamp(),",
						"          dw_updated_date = currentTimestamp(),",
						"          source_created_date = iif(isNull(CREATED), currentUTC(), toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss')),",
						"          source_updated_date = iif(isNull(UPDATED), toTimestamp('9999-12-31T00:00:00Z'), toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss'))) ~> select1",
						"select1 alterRow(upsertIf(!isNull(source_employee_id))) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['source_employee_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dwh_df_employee_history')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "HR/AzureSqlDw"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "employeeHist"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "company"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "employee"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "department"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "position"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "grade"
						},
						{
							"dataset": {
								"referenceName": "Dataset_Source",
								"type": "DatasetReference"
							},
							"name": "level"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "Dataset_Sink",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "linkedService_err",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "joinCompany"
						},
						{
							"name": "sourcesystemcode"
						},
						{
							"name": "alterRow1"
						},
						{
							"name": "joinEmployee"
						},
						{
							"name": "joinDepart"
						},
						{
							"name": "joinPosition"
						},
						{
							"name": "joinGrade"
						},
						{
							"name": "joinLevel"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "selectEmployee"
						},
						{
							"name": "select1"
						},
						{
							"name": "selectDepartment"
						},
						{
							"name": "selectPosition"
						},
						{
							"name": "selectGrade"
						},
						{
							"name": "selectLevel"
						}
					],
					"scriptLines": [
						"source(output(",
						"          HISTORYID as long,",
						"          EMPID as long,",
						"          BEGINDATE as string,",
						"          ENDDATE as string,",
						"          ORDERID as long,",
						"          ORDERTYPE as string,",
						"          COMPANYID as string,",
						"          DEPID as string,",
						"          POSITIONID as long,",
						"          GRADEID as long,",
						"          LEVELID as long,",
						"          BASEWAGE as decimal(18,4),",
						"          BASEWAGECURRCODE as string,",
						"          TSTAMP as timestamp,",
						"          CREATED as string,",
						"          CREATEDBY as string,",
						"          UPDATED as string,",
						"          UPDATEDBY as string,",
						"          IPADDRESS as string,",
						"          MACADDRESS as string,",
						"          ORDERNO as string,",
						"          ISMANUALHIST as string,",
						"          ISNOTLOCALHIST as string,",
						"          LEGALENTITYID as long,",
						"          OLDDEPNAME as string,",
						"          JOBID as long,",
						"          NOTE as string,",
						"          INSURETYPEID as long,",
						"          LABOURCONDITION as string,",
						"          ISMULT as string,",
						"          MULTYEAR as decimal(18,4),",
						"          HISTREASON as string,",
						"          HISTREASONNAMES as string,",
						"          TOTALWAGE as decimal(18,4),",
						"          EVOLVEWAGE as decimal(18,4),",
						"          CALCPERCENT as decimal(18,4),",
						"          GRADETYPEID as long,",
						"          LEVELNO as long,",
						"          FTEMAINID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> employeeHist",
						"source(output(",
						"          company_key as integer,",
						"          company_code as string,",
						"          company_name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> company",
						"source(output(",
						"          employee_key as long,",
						"          source_system_code as string,",
						"          source_employee_id as string,",
						"          company_key as integer,",
						"          employee_code as string,",
						"          registration_number as string,",
						"          family_name as string,",
						"          last_name as string,",
						"          first_name as string,",
						"          gender as string,",
						"          birth_date as date,",
						"          nationality_id as integer,",
						"          employment_status as string,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as boolean,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp,",
						"          etl_batch_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> employee",
						"source(output(",
						"          department_key as integer,",
						"          source_system_code as string,",
						"          source_department_id as string,",
						"          company_key as integer,",
						"          department_code as string,",
						"          department_name as string,",
						"          parent_department_key as integer,",
						"          department_level as string,",
						"          is_active as boolean,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as boolean,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> department",
						"source(output(",
						"          position_key as integer,",
						"          source_system_code as string,",
						"          source_position_id as string,",
						"          company_key as integer,",
						"          position_code as string,",
						"          position_name as string,",
						"          position_category as string,",
						"          position_level as string,",
						"          is_management as boolean,",
						"          is_active as boolean,",
						"          effective_start_date as timestamp,",
						"          effective_end_date as timestamp,",
						"          is_current_record as boolean,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> position",
						"source(output(",
						"          grade_key as integer,",
						"          grade_id as integer,",
						"          code as string,",
						"          grade_no as integer,",
						"          name as string,",
						"          is_active as boolean,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> grade",
						"source(output(",
						"          level_key as integer,",
						"          level_id as integer,",
						"          level_code as string,",
						"          level_name as string,",
						"          source_system_code as string,",
						"          source_created_date as timestamp,",
						"          source_updated_date as timestamp,",
						"          dw_created_date as timestamp,",
						"          dw_updated_date as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> level",
						"employeeHist, company join(COMPANYID == company_code,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinCompany",
						"joinLevel derive(source_system_code = 0,",
						"          is_current_position = 1,",
						"          is_active_employment = 1,",
						"          begin_date = toTimestamp(BEGINDATE, 'yyyy.MM.dd HH:mm:ss'),",
						"          end_date = toTimestamp(ENDDATE, 'yyyy.MM.dd HH:mm:ss'),",
						"          source_history_id = HISTORYID,",
						"          source_order_id = ORDERID,",
						"          order_type = ORDERTYPE,",
						"          order_number = ORDERNO,",
						"          level_number = LEVELID,",
						"          base_wage = BASEWAGE,",
						"          base_wage_currency = BASEWAGECURRCODE,",
						"          insurance_type_id = INSURETYPEID,",
						"          labour_condition = LABOURCONDITION,",
						"          source_created_date = toTimestamp(CREATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          source_updated_date = toTimestamp(UPDATED, 'yyyy.MM.dd HH:mm:ss'),",
						"          dw_created_date = currentUTC(),",
						"          dw_updated_date = currentUTC(),",
						"          etl_batch_id = toLong(currentUTC())) ~> sourcesystemcode",
						"sourcesystemcode alterRow(upsertIf(!isNull(source_history_id))) ~> alterRow1",
						"joinCompany, selectEmployee join(toString(EMPID) == toString(source_employee_id),",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinEmployee",
						"derivedColumn1, selectDepartment join(toString(DEPID) == source_department_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinDepart",
						"joinDepart, selectPosition join(toString(POSITIONID) == source_position_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinPosition",
						"joinPosition, selectGrade join(GRADEID == grade_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinGrade",
						"joinGrade, selectLevel join(toString(LEVELID) == toString(level_id),",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinLevel",
						"joinEmployee derive({emp_left } = toString(EMPID),",
						"          emp_right = toString(source_employee_id)) ~> derivedColumn1",
						"employee select(mapColumn(",
						"          employee_key,",
						"          source_system_code,",
						"          source_employee_id,",
						"          company_key,",
						"          employee_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectEmployee",
						"company select(mapColumn(",
						"          company_key,",
						"          company_code,",
						"          company_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"department select(mapColumn(",
						"          department_key,",
						"          source_department_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectDepartment",
						"position select(mapColumn(",
						"          position_key,",
						"          source_position_id,",
						"          position_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectPosition",
						"grade select(mapColumn(",
						"          grade_key,",
						"          grade_id,",
						"          grade_code = code,",
						"          grade_no",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectGrade",
						"level select(mapColumn(",
						"          level_key,",
						"          level_id,",
						"          level_code,",
						"          level_name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectLevel",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['source_history_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     errorHandlingOption: 'stopOnFirstError') ~> sink1"
					]
				}
			},
			"dependsOn": []
		}
	]
}